---
title: '[Rust] Drop/dropã‚ã‚Œã“ã‚Œ'
emoji: ğŸ¬
type: tech
topics: [rust]
published: true
---

:::message
ã“ã®è¨˜äº‹ã¯[Rust 3 Advent Calendar 2020](https://qiita.com/advent-calendar/2020/rust3)ã®7æ—¥ç›®ã®è¨˜äº‹ã§ã™ï¼
:::

Rustã§ã¯[`std::ops::Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html) ã¨ã„ã†ãƒˆãƒ¬ã‚¤ãƒˆã‚’ä½¿ã†ã“ã¨ã«ã‚ˆã‚Šï¼ŒC++ã¨åŒæ§˜ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å®šç¾©ã§ãã¾ã™ï¼ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå®šç¾©ã§ãã‚‹ã¨ï¼ŒRAII (Resource Acquisition Is Initialization)ã¨ã„ã†ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒä½¿ãˆï¼Œã“ã‚Œã«ã‚ˆã‚Šä»¥ä¸‹ã®ã‚ˆã†ãªå‡¦ç†ã‚’ç¢ºå®Ÿã«^[Rustã®å ´åˆ`std::mem::forget`ç­‰ã®æŠœã‘é“ã¯ã‚ã‚Šã¾ã™ãŒï¼Œã“ã‚Œã¯æ„å›³ã—ã¦ã‚„ã‚‰ãªã„ã¨ãªã‚‰ãªã„ã®ã§ä¾‹å¤–çš„]è¡Œã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼

- ç¢ºä¿ã—ãŸãƒ¡ãƒ¢ãƒªã‚’é–‹æ”¾ã™ã‚‹
- é–‹ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
- ç¢ºä¿ã—ãŸMutexç­‰ã®ãƒ­ãƒƒã‚¯ã‚’é–‹æ”¾ã™ã‚‹

ä¾‹ãˆã°ï¼ŒC++ã ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãã¨ã“ã‚ï¼Œ

```cpp
#include <iostream>
#include <string>

class Sample {
 public:
  explicit Sample(std::string name) : name_(name) {
    std::cout << "ctor " << name_ << std::endl;
  }
  ~Sample() {
    std::cout << "dtor " << name_ << std::endl;
  }
    
 private:
  std::string name_;
};


int main() {
  Sample a("A");
  {
    Sample b("B");
  }  
  std::cout << "-----" << std::endl;
}
```

```text:å‡ºåŠ›
ctor A
ctor B
dtor B
-----
dtor A
```

Rustã ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«æ›¸ãã“ã¨ã§åŒæ§˜ã®æŒ¯ã‚‹èˆã„ã«ãªã‚Šã¾ã™ï¼

[Rust Playroundã§å®Ÿè¡Œ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f7a9509468986ac30a6439fc093db18e)

```rust
#![allow(unused_variables)]

struct Sample {
    name: String
}

impl Sample {
    fn new(name: &str) -> Self {
        println!("ctor {}", name);
        Self { name: name.to_string() }
    }
}

impl Drop for Sample {
    fn drop(&mut self) {
        println!("dtor {}", self.name);
    }
}


fn main() {
    let a = Sample::new("A");
    {
        let b = Sample::new("B");
    }
    println!("-----");
}
```

```text:å‡ºåŠ›
ctor A
ctor B
dtor B
-----
dtor A
```

`Drop`ãƒˆãƒ¬ã‚¤ãƒˆã¯å”¯ä¸€ã®é–¢æ•°`fn drop(&mut self)`ã‚’æŒã£ã¦ãŠã‚Šï¼ŒRustã§ã¯å€¤ãŒã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰æŠœã‘ã‚‹ã¨ï¼Œ`Drop::drop`ãŒå†…éƒ¨çš„ã«å‘¼ã³å‡ºã•ã‚Œã¾ã™ï¼ã“ã“ã§ã¯`b`ã®æ–¹ãŒ`a`ã‚ˆã‚Šã‚‚ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ãŒçŸ­ã„ãŸã‚ï¼Œ`dtor A`ã‚ˆã‚Šå…ˆã«`dtor B`ãŒå‡ºåŠ›ã•ã‚Œã¦ã„ã¾ã™ï¼
æ™®é€šã«ä½¿ã†ãŸã‚ã®ç†è§£ã¨ã—ã¦ã¯ãŠãã‚‰ãã“ã‚Œã§ååˆ†ã§ï¼Œå®Ÿéš›Rust by Exampleã‚„TRPLã«ã¯ãã‚Œãã‚‰ã„ï¼ˆTRPLã¯`std::mem::drop`ã®è©±ã‚‚ã‚ã‚‹ãŒï¼‰ã®å†…å®¹ã—ã‹æ›¸ã‹ã‚Œã¦ã„ã¾ã›ã‚“ï¼

https://doc.rust-jp.rs/rust-by-example-ja/trait/drop.html

https://doc.rust-jp.rs/book-ja/ch15-03-drop.html

æœ€è¿‘ï¼Œå€‹äººçš„ã«FFIã¨ã‹ã—ã¦ã„ã‚‹ä¸­ã§ï¼Œã‚‚ã†å°‘ã—è©³ã—ãçŸ¥ã‚ŠãŸããªã£ãŸã®ã§è‰²ã€…ã¾ã¨ã‚ã¦ã¿ã¾ã—ãŸã¨ã„ã†è¨˜äº‹ã§ã™ï¼

## å…¥ã‚Œå­ã®å ´åˆã®å‘¼ã³å‡ºã—é †

ä¸€ç•ªçŸ¥ã‚ŠãŸã‹ã£ãŸå†…å®¹ã§ã™ãŒï¼Œ`Drop`ã‚’å®šç¾©ã—ãŸå‹ãŒå…¥ã‚Œå­ã«ãªã£ãŸå ´åˆã«å‘¼ã³å‡ºã—é †ã¯ã©ã†ãªã‚‹ã®ã§ã—ã‚‡ã†ã‹ï¼
å…¬å¼ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã«ä»¥ä¸‹ã®ã‚ˆã†ãªè¨˜è¿°ãŒã‚ã‚Šã¾ã™ï¼

> The destructor of a type `T` consists of:
>   1. If `T: Drop`, calling `<T as std::ops::Drop>::drop`
>   2. Recursively running the destructor of all of its fields.
>      - The fields of a struct are dropped in declaration order.
>      - The fields of the active enum variant are dropped in declaration order.
>      - The fields of a tuple are dropped in order.
>      - The elements of an array or owned slice are dropped from the first element to the last.
>      - The variables that a closure captures by move are dropped in an unspecified order.
>      - Trait objects run the destructor of the underlying type.
>      - Other types don't result in any further drops.

å¼•ç”¨å…ƒï¼šhttps://doc.rust-lang.org/reference/destructors.html

è¨³ã—ã¦ã¿ã¾ã™ï¼

`T`å‹ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ä»¥ä¸‹ã‹ã‚‰ãªã‚‹
  1. `T: Drop`ã‚’æº€ãŸã—ã¦ã„ã‚Œã°ï¼Œ`<T as std::ops::Drop>::drop`ã‚’å‘¼ã¶
  2. å…¨ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å†å¸°çš„ã«å®Ÿè¡Œã™ã‚‹
      - æ§‹é€ ä½“ã®å ´åˆï¼Œãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å®£è¨€é †ã«dropã•ã‚Œã‚‹
      - enumã®å ´åˆï¼Œãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å®£è¨€é †ã«dropã•ã‚Œã‚‹
      - ã‚¿ãƒ—ãƒ«ã®å ´åˆï¼Œãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯é †ç•ªé€šã‚Šdropã•ã‚Œã‚‹
      - é…åˆ—ã‚„æ‰€æœ‰ã—ã¦ã„ã‚‹ã‚¹ãƒ©ã‚¤ã‚¹ã®è¦ç´ ã¯å…ˆé ­ã‹ã‚‰dropã•ã‚Œã‚‹
      - ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£ãŒãƒ ãƒ¼ãƒ–ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ãŸå¤‰æ•°ã®dropé †åºã¯æœªæŒ‡å®š
      - ãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã¯underlying typeï¼ˆå¾Œè¿°ï¼‰ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå®Ÿè¡Œã•ã‚Œã‚‹
      - ãã®ä»–ã®å‹ã¯ãã‚Œä»¥ä¸Šã®å‡¦ç†ã‚’è¡Œã‚ãªã„ï¼ˆã¤ã¾ã‚Š1ã®ã¿ã¨ã„ã†ã“ã¨ï¼‰

ã¨ã„ã†ã“ã¨ã§ï¼Œå®Ÿéš›ã«ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦æŒ¯ã‚‹èˆã„ã‚’è¦‹ã¦ã¿ã¾ã™ï¼

[Rust Playgroundã§å®Ÿè¡Œ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=e46865a7e5f7d7b7138f5504c6f16117)

```rust
#![allow(dead_code)]

struct Parent {
    a: Child,
    b: Child,
}

impl Parent {
    fn new() -> Self {
        Self {
            a: Child::new("a"),
            b: Child::new("b"),
        }
    }
}

impl Drop for Parent {
    fn drop(&mut self) {
        println!("drop Parent");
    }
}

struct Child {
    prefix: String,
    a: GrandChild,
    b: GrandChild,
}

impl Child {
    fn new(prefix: &str) -> Self {
        Self {
            prefix: prefix.to_string(),
            a: GrandChild { msg: format!("{}_a", prefix) },
            b: GrandChild { msg: format!("{}_b", prefix) },
        }
    }
}

impl Drop for Child {
    fn drop(&mut self) {
        println!("drop Child: {}", self.prefix);
    }
}

struct GrandChild {
    msg: String,
}

impl Drop for GrandChild {
    fn drop(&mut self) {
        println!("drop GrandChild: {}", self.msg);
    }
}

fn main() {
    Parent::new();
}
```

```text:å‡ºåŠ›
drop Parent
drop Child: a
drop GrandChild: a_a
drop GrandChild: a_b
drop Child: b
drop GrandChild: b_a
drop GrandChild: b_b
```

ä»¥ä¸‹ã®è¨˜è¿°ã§1, 2ãŒé †ç•ªé€šã‚Šå‡¦ç†ã•ã‚Œã‚‹ã¨ã—ãŸã¨ãã«æƒ³å®šã•ã‚Œã‚‹é€šã‚Šã®é †ç•ªã«ãªã£ã¦ã„ã‚‹ã“ã¨ãŒç¢ºèªã§ãã¾ã—ãŸï¼

1. `T: Drop`ã‚’æº€ãŸã—ã¦ã„ã‚Œã°ï¼Œ`<T as std::ops::Drop>::drop`ã‚’å‘¼ã¶
2. å…¨ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å†å¸°çš„ã«å®Ÿè¡Œã™ã‚‹
    - æ§‹é€ ä½“ã®å ´åˆï¼Œãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å®£è¨€é †ã«dropã•ã‚Œã‚‹

## ãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿

å…ˆã®The Rust Referenceã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®èª¬æ˜ã§ï¼Œãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç®‡æ‰€ã ã‘å°‘ã—å¼•ã£ã‹ã‹ã£ãŸã®ã§ï¼Œã“ã¡ã‚‰ã‚‚è©³ã—ãè¦‹ã¦ã¿ã¾ã™ï¼

> Trait objects run the destructor of the underlying type.

å¼•ç”¨å…ƒï¼šhttps://doc.rust-lang.org/reference/destructors.html

underlying typeã¨ã„ã†ã¨C++ã®[`std::underlying_type`](https://en.cppreference.com/w/cpp/types/underlying_type)ã®ã‚ˆã†ã«ï¼ŒåŸºåº•å‹ã¨ã„ã†è¨³ãŒè¦‹ã¤ã‚Šã¾ã™ãŒï¼Œä»Šå›ã¯å°‘ã—é•ã†æ°—ãŒã—ã¾ã™ï¼
Slackã®rust-jpã‚°ãƒ«ãƒ¼ãƒ—^[å…¥ã£ã¦ãªã„äººã¯æ˜¯é https://rust-jp.herokuapp.com] ã§å°‹ã­ãŸã¨ã“ã‚ï¼Œunderlyingã®å…ƒã€…ã®æ„å‘³ã€Œéš ã•ã‚ŒãŸãƒ»è£ã«ã‚ã‚‹ãƒ»æ½œåœ¨çš„ãªã€ã¨ã—ã¦è§£é‡ˆã—ãŸæ–¹ãŒã‚ˆã„ã¨ã„ã†ã‚ˆã†ãªå›ç­”ã‚’ã„ãŸã ãã¾ã—ãŸï¼
ã¨ã„ã†ã“ã¨ã§ï¼Œã“ã“ã§ã¯ãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è£ã«ã‚ã‚‹å…ƒã®å…·è±¡å‹ã¨ã„ã†ã‚ˆã†ãªæ„å‘³åˆã„ã®ã‚ˆã†ã§ã™ï¼

```rust
#[allow(unused_variables)]

struct Concrete;

impl Drop for Concrete {
    fn drop(&mut self) {
        println!("drop from Concrete")
    }
}

trait Trait {}

impl Trait for Concrete {}

fn main() {
    let a = Box::new(Concrete {}) as Box<dyn Trait>;
    println!("-----");
}
```

```text:å‡ºåŠ›
-----
drop from Concrete
```

ãã‚‚ãã‚‚ï¼Œ`Drop`ãƒˆãƒ¬ã‚¤ãƒˆã¯ä»–ã®ãƒˆãƒ¬ã‚¤ãƒˆã¨é•ã„ï¼Œãƒˆãƒ¬ã‚¤ãƒˆã«å¯¾ã—ã¦å®Ÿè£…ã§ããªã„ã—ï¼Œå‰²ã¨æƒ³å®šé€šã‚Šã®æŒ¯ã‚‹èˆã„ã§ã—ã‚‡ã†ã‹ï¼

> Drop was implemented on a trait, which is not allowed: only structs and enums can implement Drop.

å¼•ç”¨å…ƒï¼šhttps://doc.rust-lang.org/stable/error-index.html#E0120

## `Drop` ã¨ `Copy`

`Drop`ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹å‹ã«å¯¾ã—ã¦ï¼Œ`#[derive(Copy)]`ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ï¼å®Ÿéš›ã«ã‚„ã£ã¦ã¿ã‚‹ã¨ä»¥ä¸‹ã®é€šã‚Šã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã«ãªã‚Šã¾ã™ï¼

```rust
#[derive(Copy)]
struct Sample;

impl Drop for Sample {
    fn drop(&mut self) {}
}
```

```
error[E0184]: the trait `Copy` may not be implemented for this type; the type has a destructor
 --> src/lib.rs:1:10
  |
1 | #[derive(Copy)]
  |          ^^^^ Copy not allowed on types with destructors
  |
  = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)
```

ç†ç”±ã¯`Copy`ãƒˆãƒ¬ã‚¤ãƒˆã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚ã‚Šã¾ã™ï¼ã¾ã‚å½“ç„¶ã§ï¼ŒRAIIã—ã¦ã„ã‚‹ã®ã«memcpyã ã‘ã—ã¦ã‚‚æ„å‘³ãªã„ã¨ã„ã†ç†ç”±ã®ã‚ˆã†ã§ã™ï¼

> Generalizing the latter case, any type implementing Drop can't be Copy, because it's managing some resource besides its own `size_of::<T>` bytes.

å¼•ç”¨å…ƒï¼šhttps://doc.rust-lang.org/core/marker/trait.Copy.html#when-cant-my-type-be-copy

## `Drop::drop`ãŒå‘¼ã°ã‚Œãªã„ã“ã¨ã‚’æƒ³å®šã›ã‚ˆ

`std::mem::forget`ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ä»¥ä¸‹ã®ã‚ˆã†ã«ã‚ã‚‹ã¨ãŠã‚Šï¼Œ`Drop::drop`ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ã“ã¨ã‚’safeæ€§ã®å¿…è¦æ¡ä»¶ã«ã—ã¦ã¯ã„ã‘ã¾ã›ã‚“ï¼

> `forget` is not marked as unsafe, because Rust's safety guarantees do not include a guarantee that destructors will always run. For example, a program can create a reference cycle using `Rc`, or call `process::exit` to exit without running destructors. Thus, allowing `mem::forget` from safe code does not fundamentally change Rust's safety guarantees.

å¼•ç”¨å…ƒï¼šhttps://doc.rust-lang.org/stable/std/mem/fn.forget.html#safety

ä¾‹ãˆã°ï¼Œ`Drop::drop`ä¸­ã§ä»¥ä¸‹ã®ã‚ˆã†ãªã“ã¨ã‚’ã•ã›ã¦ã„ã‚‹å ´åˆã«ï¼Œ`std::mem::forget`ã—ã¦ã‚‚ï¼Œãã‚Œãã‚Œãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã„ãŸã¾ã¾ã«ãªã£ãŸã‚Šï¼Œãƒ­ãƒƒã‚¯ãŒç¢ºä¿ã•ã‚ŒãŸã¾ã¾ã«ãªã£ãŸã‚Šã™ã‚‹ã ã‘ã§unsafeã«ã¯æ±ºã—ã¦ãªã‚Šã¾ã›ã‚“ï¼ã§ã™ã®ã§ï¼Œã“ã‚Œã‚‰ã¯safeã®è¨­è¨ˆã¨ã—ã¦æ­£ã—ã„ã“ã¨ã«ãªã‚Šã¾ã™ï¼

- é–‹ã„ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
- ç¢ºä¿ã—ãŸMutexç­‰ã®ãƒ­ãƒƒã‚¯ã‚’é–‹æ”¾ã™ã‚‹

ã§ã™ãŒï¼Œ`std::mem::forget`ã—ãŸå¾Œã«ï¼Œã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ãƒˆã™ã‚‹ã¨ãƒ¡ãƒ¢ãƒªç ´å£ŠãŒèµ·ãã‚‹ã¨ã‹ã«ãªã£ã¦ã—ã¾ã†ã¨ï¼Œãã‚Œã¯ä½•ã‹è¨­è¨ˆãŒé–“é•ã£ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã§ã™ï¼
ãã‚‚ãã‚‚ã“ã®é–¢æ•°ãŒä½•æ•…safeãªã®ã‹ã«ã¤ã„ã¦ã¯ï¼Œä»¥ä¸‹ã®è¨˜äº‹ã‚’ã”å‚ç…§ãã ã•ã„ï¼ç°¡å˜ã«è¨€ã†ã¨ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã¯safeã¨ã„ã†ã“ã¨ã§ã™ï¼

https://qnighy.hatenablog.com/entry/2017/04/14/070000

## `std::mem::drop`

https://doc.rust-lang.org/std/mem/fn.drop.html

å¥½ããªã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å€¤ã‚’ç ´æ£„ã—ãŸã„å ´åˆã«ã¯`std::mem::drop`ã‚’ä½¿ã„ã¾ã™ï¼

```rust
// çœç•¥

fn main() {
    let a = Sample::new("A");
    {
        let b = Sample::new("B");
        std::mem::drop(a);
    }
}
```

```text:å‡ºåŠ›
ctor A
ctor B
dtor A
dtor B
```

ã¨ã“ã‚ã§ï¼Œ`std::mem::drop`ã®[å®Ÿè£…](https://doc.rust-lang.org/src/core/mem/mod.rs.html#881)ã¯ä»¥ä¸‹ã®é€šã‚Šç©ºã®é–¢æ•°ã§ã™ï¼

```rust
pub fn drop<T>(_x: T) {}
```

ã“ã‚Œã‚’åˆã‚ã¦è¦‹ãŸã¨ãï¼Œã‚ã‚‹ç¨‹åº¦äºˆæƒ³ã—ã¦ã„ãŸã‚‚ã®ã®çµæ§‹é©šã„ãŸã®ã§ã™ãŒï¼Œçš†ã•ã‚“ã¯ã©ã†ã§ã—ã‚‡ã†ã‹ï¼ä»•çµ„ã¿ã¯å˜ç´”ã§ï¼Œä½•ã‚‚ã—ãªã„é–¢æ•°ã«å€¤ã‚’ãƒ ãƒ¼ãƒ–ã™ã‚Œã°ï¼Œãã®ã¾ã¾ãƒ©ã‚¤ãƒ•ãƒ©ã‚¤ãƒ ãŒå°½ãã‚‹ã¨ã„ã†ã ã‘ã§ã™ï¼
ãã®ãŸã‚ï¼Œå‡¦ç†å†…å®¹çš„ã«ã¯ä»¥ä¸‹ã§ã‚‚ã‚ˆã„ã‚ã‘ã§ã™ãŒï¼Œãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã ã¨è­¦å‘ŠãŒå‡ºã¾ã™ï¼å®Ÿéš›æ„å›³ãŒæ˜ç¢ºã§ãªã„ã®ã§é¿ã‘ã‚‹ã¹ãã§ã—ã‚‡ã†ï¼

```rust
// çœç•¥

fn main() {
    let a = Sample::new("A");
    {
        let b = Sample::new("B");
	a;  // drop
    }
}
```

```
warning: path statement drops value
  --> src/main.rs:23:9
   |
23 |         a;  // drop
   |         ^^^ help: use `drop` to clarify the intent: `drop(a);`
   |
   = note: `#[warn(path_statements)]` on by default
```

## `std::mem::forget`

https://doc.rust-lang.org/std/mem/fn.forget.html

ã“ã®é–¢æ•°ã‚’ä½¿ã†ã“ã¨ã§ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå€¤ã®ç ´æ£„æ™‚ã«å‘¼ã³å‡ºã•ã‚Œãªã„ã‚ˆã†ã«ã§ãã¾ã™ï¼

```rust
// æ§‹é€ ä½“å®šç¾©ã¯åŒæ§˜ãªã®ã§çœç•¥

fn main() {
    let a = Sample::new("A");
    std::mem::forget(a);
}
```

```text:å‡ºåŠ›
ctor A
```

æ³¨æ„ç‚¹ã¨ã—ã¦ã¯ï¼Œå€¤ã‚’è¦æ±‚ã—ã¦ã„ã‚‹ã®ã§å°‘ã—ä½¿ã„å‹æ‰‹ãŒæ‚ªã„ã§ã™ï¼ˆã¾ã‚æ–‡å­—é€šã‚Š`forget`ãªã®ã§ï¼‰ï¼ãã®å ´åˆã¯å¾Œè¿°ã™ã‚‹[`ManuallyDrop`](https://doc.rust-lang.org/beta/std/mem/struct.ManuallyDrop.html)ã‚’ç›´æ¥ä½¿ã†ã¨ã‚ˆã„ã§ã—ã‚‡ã†ï¼
ã¾ãŸï¼Œä»¥ä¸‹ã®ã‚ˆã†ã«ã‚ã‚‹é€šã‚Šï¼Œã‚ãã¾ã§ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã³å‡ºã•ã‚Œãªã„ã ã‘ã§ï¼Œè‡ªèº«ã®ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã‚’ä¿è¨¼ã—ã¦ã„ã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã§ãã®ç‚¹ã‚‚æ³¨æ„ã—ã¾ã—ã‚‡ã†ï¼ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã•ã›ãŸã„å ´åˆã¯[`Box::leak`](https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak)ã‚„[`Box::into_raw`](https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw)ãŒä½¿ãˆã¾ã™ï¼

> However, it does not guarantee that pointers to this memory will remain valid.
 
å¼•ç”¨å…ƒï¼šhttps://doc.rust-lang.org/std/mem/fn.forget.html

ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã«ã¯ä½¿ãˆãªã„ã¨ã„ã†ã“ã¨ãªã®ã§ï¼Œä½¿ã„ã©ã“ã‚ã¨ã—ã¦ã¯ï¼Œä»¥ä¸‹ã®ã‚ˆã†ãªå ´åˆãã‚‰ã„ã§ã—ã‚‡ã†ã‹ï¼

- å˜ã«`Drop::drop`ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ãŸã„
- unsafeé–¢æ•°ã‚’ä½¿ã£ãŸçµæœï¼ŒåŒã˜ãƒ¡ãƒ¢ãƒªã‚’æŒ‡ã—ã¦ã„ã‚‹å®Ÿä½“ãŒ2ã¤ã§ãã¦ã—ã¾ã£ãŸã®ã§ï¼ŒäºŒé‡è§£æ”¾ã«ãªã‚‰ãªã„ã‚ˆã†ã«ï¼Œä¸€æ–¹ã‚’`std::mem::forget`ã™ã‚‹

ã“ã®é–¢æ•°ã®å®Ÿè£…ã‚‚ä»¥ä¸‹ã®é€šã‚Šéå¸¸ã«å˜ç´”ã§ï¼Œ`ManuallyDrop`ã«åŒ…ã‚“ã§ã„ã‚‹ã ã‘ã§ã™ï¼`ManuallyDrop`ã¯ãã®åã®é€šã‚Š`Drop`ã‚’ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã§æ‰±ã†ãŸã‚ã®æ§‹é€ ä½“ã§ï¼Œæ˜ç¤ºçš„ã«å‘¼ã³å‡ºã•ãªã„é™ã‚Š`T`ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒå‘¼ã°ã‚Œã¾ã›ã‚“ï¼

```rust
pub const fn forget<T>(t: T) {
    let _ = ManuallyDrop::new(t);
}
```

## `std::mem::ManuallyDrop`

https://doc.rust-lang.org/beta/std/mem/struct.ManuallyDrop.html

`ManuallyDrop`ã‚’ä½¿ã†ã“ã¨ã§ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®åˆ¶å¾¡ãŒæŸ”è»Ÿã«è¡Œãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼`Deref<Targe=T>`ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã®ã§ï¼Œ`T`å‹ã¨åŒã˜ã‚ˆã†ã«æ‰±ãˆã¾ã™ã—ï¼Œã‚¼ãƒ­ã‚³ã‚¹ãƒˆãªã®ã§FFIã¨ã‚‚ç›¸æ€§ãŒã„ã„æ°—ãŒã—ã¾ã™ï¼ˆä»Šã®ã¨ã“ã‚ä½¿ã‚ãšã«æ¸ˆã‚“ã§ã„ã‚‹ã®ã§è‡ªä¿¡ã¯ã‚ã‚Šã¾ã›ã‚“ãŒï¼‰ï¼

[Rust Playgroundã§å®Ÿè¡Œ](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=3dc14e2c5e42292423a687555f3fb8e7)

```rust
#![allow(dead_code)]

use std::mem::ManuallyDrop;

struct Parent {
    a: ManuallyDrop<Child>,
    b: ManuallyDrop<Child>,
    c: ManuallyDrop<Child>,
}

impl Parent {
    fn new() -> Self {
        Self {
            a: ManuallyDrop::new(Child::new("a")),
            b: ManuallyDrop::new(Child::new("b")),
            c: ManuallyDrop::new(Child::new("c")),
        }
    }
}

impl Drop for Parent {
    fn drop(&mut self) {
        unsafe { ManuallyDrop::drop(&mut self.b); }
        println!("drop Parent");
        unsafe { ManuallyDrop::drop(&mut self.a); }
    }
}

struct Child {
    name: String,
}

impl Child {
    fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
        }
    }
}

impl Drop for Child {
    fn drop(&mut self) {
        println!("drop Child: {}", self.name);
    }
}

fn main() {
    Parent::new();
}
```

```text:å‡ºåŠ›
drop Child: b
drop Parent
drop Child: a
```

moveã§ãã‚‹ãªã‚‰`ManuallyDrop::into_inner`ã®è¿”ã‚Šå€¤ã‚’æ¨ã¦ã‚‹ã®ãŒå®‰å…¨ã§ä¸€ç•ªãªã®ã§ã™ãŒï¼Œå‚ç…§ãªã®ã§`MannualyDrop::drop`ã‚’ä½¿ã†ã—ã‹ã‚ã‚Šã¾ã›ã‚“ï¼
ä»¥ä¸‹ã®ã‚ˆã†ãªï¼ŒäºŒé‡è§£æ”¾ã™ã‚‹ã‚ˆã†ãªå±é™ºãªã‚³ãƒ¼ãƒ‰ã‚‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒé€šã£ã¦ã—ã¾ã„ã¾ã™ã—ï¼Œ`MannualyDrop::drop`ã—ãŸå¾Œã«`ManuallyDrop::into_inner`ã¨ã‹è‰²ã€…å±é™ºã“ã¨ãŒã§ãã¦ã—ã¾ã„ã¾ã™ãŒï¼Œä¸Šã®ä¾‹ã®ã‚ˆã†ã«`Drop::drop`å†…ã§ä½¿ã†ãã‚‰ã„ãªã‚‰æ¯”è¼ƒçš„å®‰å…¨ã§ã™ï¼

```rust
unsafe {
    ManuallyDrop::drop(&mut self.b);
    ManuallyDrop::drop(&mut self.b);
}
```

ã¾ãŸï¼Œãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã•ãªã„ã¨ã„ã†ç›®çš„ãªã‚‰ï¼Œä½•ã‚‚ã—ãªãã¦ã‚ˆã„ã®ã§å®‰å…¨ã§ã™ï¼

## ãã®ä»–

åŠ›å°½ããŸ

- [`std::ptr::drop_in_place`](https://doc.rust-lang.org/std/ptr/fn.drop_in_place.html)

## ãã®ä»–å‚è€ƒè¨˜äº‹

- [ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®Dropé †åº - yohhoyã®æ—¥è¨˜](https://yohhoy.hatenadiary.jp/entry/20190211/p1) 
- [Drop Checkerã®è¦å‰‡ã‚’ã¡ã‚ƒã‚“ã¨ç†è§£ã™ã‚‹ - ç°¡æ½”ãªQ](https://qnighy.hatenablog.com/entry/2018/01/01/220000)
  - è¨˜äº‹ã«ã“ã“ã¾ã§ã®å†…å®¹ã¯ç››ã‚Šè¾¼ã‚“ã§ã„ãªã„ãŒèˆˆå‘³ãŒã‚ã‚Œã°æ˜¯é 
- [stack overflow: Why does Rust not allow the copy and drop traits on one type?](https://stackoverflow.com/questions/51704063/why-does-rust-not-allow-the-copy-and-drop-traits-on-one-type)
